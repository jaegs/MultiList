namespace Cobra.Core

	class MultiList<of T>
		"""
		This class provides an n-dimensional multi-list containing any other type.

		The class provides initialization for any number of dimensions, access to the data via
		indexing (`m[i, j, k]`) and equality comparisons between matrices.
	
		The dimension sizes and even the number of dimensions may be hard-coded or delayed until
		run-time.

		See the class TestMultiList further below for example usage.
		
		This is similar in concept to C++'s Boost.MultiArray though this class is not modeled
		directly after it.
		"""

		const minDimRank = 1
		const maxDimRank = 10_000_000
		const maxCount = 2_100_000_000
	
		var _shape as IList<of int>
		var _count = 1
		var _data as T[]

		cue init(shape as vari int)
			require
				shape.length > 0
				all for dim in shape get dim >= .minDimRank and dim <= .maxDimRank
			body
				.init(shape.toList)

		cue init(shape as IList<of int>)
			require
				shape.count > 0
				all for dim in shape get dim >= .minDimRank and dim <= .maxDimRank
			body
				base.init
				_shape = shape.clone
				for dim in shape, _count *= dim
				assert _count < .maxCount
				_data = T[](_count)
				assert _data.length == _count
	
		get count from var
	
		get shape as IList<of int>
			return _shape.clone

		pro [indexes as vari int] as T
			get
				require indexes.length == .shape.count
				return _data[_address(indexes)]
			set
				require indexes.length == .shape.count
				_data[_address(indexes)] = value

		def items as T*
			""" Returns all the items in the multi-list, one at a time, in row-major order. """
			for item in _data, yield item

		def equals(m as MultiList<of T>) as bool
			if m.count <> .count, return false
			if m._shape <> _shape, return false
			for i in _count, if m._data[i] <> _data[i], return false
			return true

		def equals(obj as Object?) as bool is override
			if obj inherits MultiList<of T>, return .equals(obj)
			return false

		def getHashCode as int is override
			throw InvalidOperationException('Highly mutable classes do not have dependable hash codes.')

		def _address(indexes as vari int) as int
			assert indexes.length == _shape.count
			# The below calcs are "row-major order", if it matters.
			# See http://en.wikipedia.org/wiki/Row-major_order#Generalization_to_higher_dimensions
			address = 0
			len = indexes.length
			for i in len
				index = indexes[i]
				if index < 0 or index >= _shape[i]
					throw IndexOutOfRangeException('Array index [index] is out of range 0 - [_shape[i]] for dimension [i].')
				x = 1
				for j in i+1 : len, x *= _shape[j]
				x *= index
				address += x
			return address


	class TestMultiList

		test
			m = MultiList<of int>(1)
			assert m.count == 1
			assert m[0] == 0
			m[0] = 42
			assert m[0] == 42
			expect IndexOutOfRangeException, print m[1]
		
			m = MultiList<of int>(3, 7)
			assert m.count == 21
			for x in 3, for y in 7, m[x, y] = x*y
			for x in 3, for y in 7, assert m[x, y] == x*y
			expect IndexOutOfRangeException, print m[3, 7]
			expect IndexOutOfRangeException, print m[3, 0]
			expect IndexOutOfRangeException, print m[0, 7]
			expect IndexOutOfRangeException, print m[4, 8]
		
			d1, d2, d3 = 10, 5, 3
			m = MultiList<of int>(d1, d2, d3)
			assert m.count == d1 * d2 * d3
			for x in d1, for y in d2, for z in d3, m[x, y, z] = x*y*z
			for x in d1, for y in d2, for z in d3, assert m[x, y, z] == x*y*z
		
			shape = [d1, d2, d3]
			m2 = MultiList<of int>(shape)
			for x in d1, for y in d2, for z in d3, m2[x, y, z] = x*y*z
			for x in d1, for y in d2, for z in d3, assert m2[x, y, z] == x*y*z
			assert m2 == m
			m2[0, 0, 0] += 1
			assert m2 <> m

			m = MultiList<of int>(2, 2)
			n = 1
			for x in 2
				for y in 2
					m[x, y] = n
					n += 1
			assert m.items.toList == [1, 2, 3, 4]

